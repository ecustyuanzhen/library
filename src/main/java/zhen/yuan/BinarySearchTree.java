package zhen.yuan;/** * @Author:zhenyuan * @Date:Created in 20:59 2018/7/1 */public class BinarySearchTree<T extends Comparable<? super T>> {    //节点定义    private static class BinarryNode<T> {        T element;        BinarryNode<T> left;        BinarryNode<T> right;        public BinarryNode(T element, BinarryNode<T> left, BinarryNode<T> right) {            this.element = element;            this.left = left;            this.right = right;        }        public BinarryNode(T element) {            this(element, null, null);        }    }    public BinarryNode<T> root;    public BinarySearchTree() {        root = null;    }    public void makeEmpty() {        root = null;    }    public boolean isEmpty() {        return null == root;    }    public boolean contains(T element) {        return contains(element, root);    }    public T findMin() throws Exception {        if (isEmpty()) {            throw new Exception("Tree is null");        }        return findMin(root).element;    }    public void insert(T element) {        root = insert(element, root);    }    public void remove(T element) {        root = remove(element, root);    }    public void printTree() {        printTree(root);    }    private boolean contains(T element, BinarryNode<T> binarryNode) {        if (binarryNode.element.compareTo(element) == 0) {            return true;        }        if (binarryNode.element.compareTo(element) > 0 && binarryNode.left != null) {            return contains(element, binarryNode.left);        }        if (binarryNode.element.compareTo(element) < 0 && binarryNode.right != null) {            return contains(element, binarryNode.right);        }        return false;    }    private BinarryNode<T> findMin(BinarryNode<T> binarryNode) {        while (binarryNode.left != null) {            return findMin(binarryNode.left);        }        return binarryNode;    }    private BinarryNode<T> insert(T element, BinarryNode<T> binarryNode) {        if (isEmpty()) {            return new BinarryNode<T>(element);        }        if (binarryNode.element.compareTo(element) > 0) {            if (binarryNode.left != null) {                return insert(element, binarryNode.left);            }            binarryNode.left = new BinarryNode<T>(element);        }        if (binarryNode.element.compareTo(element) < 0) {            if (binarryNode.right != null) {                return insert(element, binarryNode.right);            }            binarryNode.right = new BinarryNode<T>(element);        }        return root;    }    private BinarryNode<T> remove(T element, BinarryNode<T> binarryNode) {        if (binarryNode==null){            return binarryNode;        }        int result=element.compareTo(binarryNode.element);        if (result>0){binarryNode.right=remove(element,binarryNode.right);}        else if (result<0){binarryNode.left= remove(element,binarryNode.left);}        else if (binarryNode.left!=null&&binarryNode.right!=null){            binarryNode.element=findMin(binarryNode).element;            binarryNode.right=remove(element,binarryNode.right);        }else {binarryNode= (binarryNode.right!=null)? binarryNode.right:binarryNode.left;}        return binarryNode;    }    private void printTree(BinarryNode<T> binarryNode) {        if (binarryNode!=null){            printTree(binarryNode.left);            System.out.print(binarryNode.element+" ");            printTree(binarryNode.right);        }    }}